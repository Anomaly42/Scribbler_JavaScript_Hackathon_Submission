{
  "metadata": {
    "name": "New JSNB",
    "language_info": {
      "name": "JavaScipt",
      "version": "8.0"
    }
  },
  "jsnbversion": "v0.1",
  "cells": [
    {
      "code": "<h1>Fun with Shaders!</h1>\n<h3>By Team: NaamMeinKyaRakhaHai</h3>",
      "status": "",
      "output": "<h1>Fun with Shaders!</h1>\n<h3>By Team: NaamMeinKyaRakhaHai</h3>",
      "type": "html"
    },
    {
      "code": "<h2>Part I: Shader Programming 101<h2>",
      "status": "",
      "output": "<h2>Part I: Shader Programming 101</h2><h2></h2>",
      "type": "html"
    },
    {
      "code": "Shader Programming refers to writing programs designed to run on the GPU, unlike most programs familiar to us, which are of course tailored to run on CPUs. \n<br>\n  The amazing thing about GPUs is that they are designed to run a huge number of identical programs all at once on separate cores, which could likely be in the thousands.\n  <br>\n<br>\nTo stay within the scope of this notebook, we will skip over most of the wonderful things shader programs can do, such as almost all of computer graphics, VFX, image processing, particle\nsystems etc. and focus on the most basic way one can write a shader program:\n<br>\n  <br>\n  Suppose that, you are provided with a function you have to fill in. The inputs to the function are the x and y coordinates of a pixel on the screen, and the output you are supposed to give is the color\n  corresponding to that pixel, i.e. you have to write the function f(x, y) -> color. When such a program is run on the GPU, the same function will be run in parallel for all pixels, and thus the resilt will be MUCH faster that executing the same program sequentially i.e. pixel-by-pixel on the CPU.",
      "status": "",
      "output": "Shader Programming refers to writing programs designed to run on the GPU, unlike most programs familiar to us, which are of course tailored to run on CPUs. \n<br>\n  The amazing thing about GPUs is that they are designed to run a huge number of identical programs all at once on separate cores, which could likely be in the thousands.\n  <br>\n<br>\nTo stay within the scope of this notebook, we will skip over most of the wonderful things shader programs can do, such as almost all of computer graphics, VFX, image processing, particle\nsystems etc. and focus on the most basic way one can write a shader program:\n<br>\n  <br>\n  Suppose that, you are provided with a function you have to fill in. The inputs to the function are the x and y coordinates of a pixel on the screen, and the output you are supposed to give is the color\n  corresponding to that pixel, i.e. you have to write the function f(x, y) -&gt; color. When such a program is run on the GPU, the same function will be run in parallel for all pixels, and thus the resilt will be MUCH faster that executing the same program sequentially i.e. pixel-by-pixel on the CPU.",
      "type": "html"
    },
    {
      "code": "<h3> Julia Set</h3>\n  The Julia sets (see <a href=\"https://en.wikipedia.org/wiki/Julia_set\">here</a>) is a complex set defined using the iteration of z<sup>2</sup> + c (starting from z = 0), where c is some complex number. If \n\t\t\t\t  the iteration converges, it is part of the set. Additionally, we can assign colors to points not in the set depending on how slow they are to diverge; but most importantly, the color at a point only depends on the coordinate, thus the Julia Set is highly suitable to be made into a shader program.",
      "status": "",
      "output": "<h3> Julia Set</h3>\n  The Julia sets (see <a href=\"https://en.wikipedia.org/wiki/Julia_set\">here</a>) is a complex set defined using the iteration of z<sup>2</sup> + c (starting from z = 0), where c is some complex number. If \n\t\t\t\t  the iteration converges, it is part of the set. Additionally, we can assign colors to points not in the set depending on how slow they are to diverge; but most importantly, the color at a point only depends on the coordinate, thus the Julia Set is highly suitable to be made into a shader program.",
      "type": "html"
    },
    {
      "code": "<h3>Implementation Details</h3>\nWe will use WebGL to render our shader programs using JavaScript. The actual program is written in GLSL. Using WebGL features such as uniforms, we can pass information from the JavaScript code (such as the mouse position) into the shader program to make it interactive. For more details on the concepts involved, see <a href=\"https://webgl2fundamentals.org/webgl/lessons/webgl-fundamentals.html\">this explainer</a>.\n<br>\n  <br>\n  Also, implementing this within a JS notebook (instead of, say, a python notebook) offers excellent interactivity, since the canvases defined within the JS notebook are basically child elements on the notebook, which enables us to find the canvas coordinates relative to the notebook coordinates and allow the mouse position based interactivity to work correctly. The implementation is the following (move your mouse over the canvas to see Julia sets for different values of c!):",
      "status": "",
      "output": "<h3>Implementation Details</h3>\nWe will use WebGL to render our shader programs using JavaScript. The actual program is written in GLSL. Using WebGL features such as uniforms, we can pass information from the JavaScript code (such as the mouse position) into the shader program to make it interactive. For more details on the concepts involved, see <a href=\"https://webgl2fundamentals.org/webgl/lessons/webgl-fundamentals.html\">this explainer</a>.\n<br>\n  <br>\n  Also, implementing this within a JS notebook (instead of, say, a python notebook) offers excellent interactivity, since the canvases defined within the JS notebook are basically child elements on the notebook, which enables us to find the canvas coordinates relative to the notebook coordinates and allow the mouse position based interactivity to work correctly. The implementation is the following (move your mouse over the canvas to see Julia sets for different values of c!):",
      "type": "html"
    },
    {
      "code": "<canvas id=\"myCanvas\" style=\"width:640px;height:480px;\"></canvas>\n    <script id=\"vertex-shader-2d\" type=\"x-shader/x-vertex\">#version 300 es\n        in vec2 a_position;\n        void main() {\n            gl_Position = vec4(a_position, 0, 1);\n        }\n    </script>\n\n    <script id=\"fragment-shader-2d\" type=\"x-shader/x-fragment\">#version 300 es\n        //gl_FragCoord contains the pixel coordinates of the fragment\n        precision highp float;\n        uniform vec2 u_mouseLocation;\n        uniform vec2 u_canvasSize;\n        out vec4 outColor;\n\n        vec2 fragSpaceToComplex(vec2 fragCoord, float x_axis_width){\n            float canvas_x = u_canvasSize.x;\n            float canvas_y = u_canvasSize.y;\n\n            vec2 coord = fragCoord.xy - vec2(canvas_x/2.0, canvas_y/2.0);\n            coord = x_axis_width * (coord / canvas_x);\n            return coord;\n        }\n\n        vec2 func(vec2 z, vec2 c){\n            return vec2(z.x*z.x - z.y*z.y + c.x, 2.00 * z.x * z.y + c.y);\n        }\n\n        //snippet from: https://gpfault.net/posts/mandelbrot-webgl.txt.html\n        vec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n            return a + b*cos( 6.28318*(c*t+d) );\n        }\n\n        vec3 colorScheme1(float t){\n            //put in random colors\n            if (t < 0.1){\n                return vec3(0.0, 0.0, 0.5); // Dark Blue\n            } else if (t < 0.2){\n                return vec3(0.0, 0.0, 1.0); // Blue\n            } else if (t < 0.3){\n                return vec3(0.0, 0.5, 1.0); // Light Blue\n            } else if (t < 0.4){\n                return vec3(0.0, 1.0, 1.0); // Cyan\n            } else if (t < 0.5){\n                return vec3(0.0, 1.0, 0.5); // Turquoise\n            } else if (t < 0.6){\n                return vec3(0.0, 1.0, 0.0); // Green\n            } else if (t < 0.7){\n                return vec3(0.5, 1.0, 0.0); // Light Green\n            } else if (t < 0.8){\n                return vec3(1.0, 1.0, 0.0); // Yellow\n            } else if (t < 0.9){\n                return vec3(1.0, 0.5, 0.0); // Orange\n            } else {\n                return vec3(1.0, 0.0, 0.0); // Red\n            }\n        }\n\n        vec3 colorScheme2(float t){\n            if (t < 0.1){\n                return vec3(0.0, 0.0, 0.5); // Dark Blue\n            } else if (t < 0.2){\n                return vec3(0.0, 0.0, 1.0); // Blue\n            } else if (t < 0.3){\n                return vec3(0.0, 0.5, 1.0); // Light Blue\n            } else if (t < 0.4){\n                return vec3(0.0, 0.75, 1.0); // Sky Blue\n            } else if (t < 0.5){\n                return vec3(0.5, 0.75, 1.0); // Light Sky Blue\n            } else if (t < 0.6){\n                return vec3(0.75, 0.75, 1.0); // Very Light Blue\n            } else if (t < 0.7){\n                return vec3(0.9, 0.9, 1.0); // Pale Blue\n            } else if (t < 0.8){\n                return vec3(0.95, 0.95, 1.0); // Very Pale Blue\n            } else if (t < 0.9){\n                return vec3(1.0, 1.0, 1.0); // White\n            } else {\n                return vec3(0.9, 0.9, 0.9); // Light Grey\n            }\n\n        }\n\n        vec3 colorScheme3(float t){\n            if (t < 0.1){\n                return vec3(0.0, 0.5, 0.0); // Dark Green\n            } else if (t < 0.2){\n                return vec3(0.0, 0.75, 0.0); // Green\n            } else if (t < 0.3){\n                return vec3(0.5, 1.0, 0.0); // Light Green\n            } else if (t < 0.4){\n                return vec3(0.75, 1.0, 0.0); // Yellowish Green\n            } else if (t < 0.5){\n                return vec3(1.0, 1.0, 0.0); // Yellow\n            } else if (t < 0.6){\n                return vec3(1.0, 0.75, 0.0); // Orange\n            } else if (t < 0.7){\n                return vec3(1.0, 0.5, 0.0); // Dark Orange\n            } else if (t < 0.8){\n                return vec3(0.5, 0.25, 0.0); // Brown\n            } else if (t < 0.9){\n                return vec3(0.5, 0.25, 0.25); // Dark Brown\n            } else {\n                return vec3(0.25, 0.125, 0.125); // Very Dark Brown\n            }\n\n        }\n\n        \n        vec3 colorScheme4(float t){\n            if (t < 0.1){\n                return vec3(0.5, 0.0, 0.5); // Purple\n            } else if (t < 0.2){\n                return vec3(0.75, 0.0, 0.75); // Light Purple\n            } else if (t < 0.3){\n                return vec3(1.0, 0.0, 1.0); // Magenta\n            } else if (t < 0.4){\n                return vec3(1.0, 0.0, 0.75); // Pinkish Magenta\n            } else if (t < 0.5){\n                return vec3(1.0, 0.0, 0.5); // Pink\n            } else if (t < 0.6){\n                return vec3(1.0, 0.25, 0.5); // Light Pink\n            } else if (t < 0.7){\n                return vec3(1.0, 0.5, 0.5); // Salmon\n            } else if (t < 0.8){\n                return vec3(1.0, 0.75, 0.75); // Light Salmon\n            } else if (t < 0.9){\n                return vec3(1.0, 1.0, 1.0); // White\n            } else {\n                return vec3(0.9, 0.9, 0.9); // Light Grey\n            }\n\n        }\n\n\n        void main() {\n            bool escaped = false;\n            int num_iterations = 200;\n            int i = 0;\n            float x_axis_width = 3.5;\n\n            vec2 c = fragSpaceToComplex(u_mouseLocation, x_axis_width);\n            vec2 z = fragSpaceToComplex(gl_FragCoord.xy, x_axis_width);\n\n            float escape_radius = 10.0;\n\n            for (i = 0; i < num_iterations; i++) {\n                z = func(z, c);\n                \n                if (length(z) > escape_radius) {\n                    escaped = true;\n                    break;\n                }\n            }\n\n            if (escaped) {\n                float param = float(i) / float(num_iterations);\n                vec3 finalColor = colorScheme4(param);\n                outColor = vec4(finalColor, 1);\n                \n            } else {\n                outColor = vec4(vec3(0, 0, 0), 1.0);\n            }\n        }\n    </script>",
      "status": "",
      "output": "<canvas id=\"myCanvas\" style=\"width:640px;height:480px;\" width=\"640\" height=\"480\"></canvas>\n    <script id=\"vertex-shader-2d\" type=\"x-shader/x-vertex\">#version 300 es\n        in vec2 a_position;\n        void main() {\n            gl_Position = vec4(a_position, 0, 1);\n        }\n    </script>\n\n    <script id=\"fragment-shader-2d\" type=\"x-shader/x-fragment\">#version 300 es\n        //gl_FragCoord contains the pixel coordinates of the fragment\n        precision highp float;\n        uniform vec2 u_mouseLocation;\n        uniform vec2 u_canvasSize;\n        out vec4 outColor;\n\n        vec2 fragSpaceToComplex(vec2 fragCoord, float x_axis_width){\n            float canvas_x = u_canvasSize.x;\n            float canvas_y = u_canvasSize.y;\n\n            vec2 coord = fragCoord.xy - vec2(canvas_x/2.0, canvas_y/2.0);\n            coord = x_axis_width * (coord / canvas_x);\n            return coord;\n        }\n\n        vec2 func(vec2 z, vec2 c){\n            return vec2(z.x*z.x - z.y*z.y + c.x, 2.00 * z.x * z.y + c.y);\n        }\n\n        //snippet from: https://gpfault.net/posts/mandelbrot-webgl.txt.html\n        vec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n            return a + b*cos( 6.28318*(c*t+d) );\n        }\n\n        vec3 colorScheme1(float t){\n            //put in random colors\n            if (t < 0.1){\n                return vec3(0.0, 0.0, 0.5); // Dark Blue\n            } else if (t < 0.2){\n                return vec3(0.0, 0.0, 1.0); // Blue\n            } else if (t < 0.3){\n                return vec3(0.0, 0.5, 1.0); // Light Blue\n            } else if (t < 0.4){\n                return vec3(0.0, 1.0, 1.0); // Cyan\n            } else if (t < 0.5){\n                return vec3(0.0, 1.0, 0.5); // Turquoise\n            } else if (t < 0.6){\n                return vec3(0.0, 1.0, 0.0); // Green\n            } else if (t < 0.7){\n                return vec3(0.5, 1.0, 0.0); // Light Green\n            } else if (t < 0.8){\n                return vec3(1.0, 1.0, 0.0); // Yellow\n            } else if (t < 0.9){\n                return vec3(1.0, 0.5, 0.0); // Orange\n            } else {\n                return vec3(1.0, 0.0, 0.0); // Red\n            }\n        }\n\n        vec3 colorScheme2(float t){\n            if (t < 0.1){\n                return vec3(0.0, 0.0, 0.5); // Dark Blue\n            } else if (t < 0.2){\n                return vec3(0.0, 0.0, 1.0); // Blue\n            } else if (t < 0.3){\n                return vec3(0.0, 0.5, 1.0); // Light Blue\n            } else if (t < 0.4){\n                return vec3(0.0, 0.75, 1.0); // Sky Blue\n            } else if (t < 0.5){\n                return vec3(0.5, 0.75, 1.0); // Light Sky Blue\n            } else if (t < 0.6){\n                return vec3(0.75, 0.75, 1.0); // Very Light Blue\n            } else if (t < 0.7){\n                return vec3(0.9, 0.9, 1.0); // Pale Blue\n            } else if (t < 0.8){\n                return vec3(0.95, 0.95, 1.0); // Very Pale Blue\n            } else if (t < 0.9){\n                return vec3(1.0, 1.0, 1.0); // White\n            } else {\n                return vec3(0.9, 0.9, 0.9); // Light Grey\n            }\n\n        }\n\n        vec3 colorScheme3(float t){\n            if (t < 0.1){\n                return vec3(0.0, 0.5, 0.0); // Dark Green\n            } else if (t < 0.2){\n                return vec3(0.0, 0.75, 0.0); // Green\n            } else if (t < 0.3){\n                return vec3(0.5, 1.0, 0.0); // Light Green\n            } else if (t < 0.4){\n                return vec3(0.75, 1.0, 0.0); // Yellowish Green\n            } else if (t < 0.5){\n                return vec3(1.0, 1.0, 0.0); // Yellow\n            } else if (t < 0.6){\n                return vec3(1.0, 0.75, 0.0); // Orange\n            } else if (t < 0.7){\n                return vec3(1.0, 0.5, 0.0); // Dark Orange\n            } else if (t < 0.8){\n                return vec3(0.5, 0.25, 0.0); // Brown\n            } else if (t < 0.9){\n                return vec3(0.5, 0.25, 0.25); // Dark Brown\n            } else {\n                return vec3(0.25, 0.125, 0.125); // Very Dark Brown\n            }\n\n        }\n\n        \n        vec3 colorScheme4(float t){\n            if (t < 0.1){\n                return vec3(0.5, 0.0, 0.5); // Purple\n            } else if (t < 0.2){\n                return vec3(0.75, 0.0, 0.75); // Light Purple\n            } else if (t < 0.3){\n                return vec3(1.0, 0.0, 1.0); // Magenta\n            } else if (t < 0.4){\n                return vec3(1.0, 0.0, 0.75); // Pinkish Magenta\n            } else if (t < 0.5){\n                return vec3(1.0, 0.0, 0.5); // Pink\n            } else if (t < 0.6){\n                return vec3(1.0, 0.25, 0.5); // Light Pink\n            } else if (t < 0.7){\n                return vec3(1.0, 0.5, 0.5); // Salmon\n            } else if (t < 0.8){\n                return vec3(1.0, 0.75, 0.75); // Light Salmon\n            } else if (t < 0.9){\n                return vec3(1.0, 1.0, 1.0); // White\n            } else {\n                return vec3(0.9, 0.9, 0.9); // Light Grey\n            }\n\n        }\n\n\n        void main() {\n            bool escaped = false;\n            int num_iterations = 200;\n            int i = 0;\n            float x_axis_width = 3.5;\n\n            vec2 c = fragSpaceToComplex(u_mouseLocation, x_axis_width);\n            vec2 z = fragSpaceToComplex(gl_FragCoord.xy, x_axis_width);\n\n            float escape_radius = 10.0;\n\n            for (i = 0; i < num_iterations; i++) {\n                z = func(z, c);\n                \n                if (length(z) > escape_radius) {\n                    escaped = true;\n                    break;\n                }\n            }\n\n            if (escaped) {\n                float param = float(i) / float(num_iterations);\n                vec3 finalColor = colorScheme4(param);\n                outColor = vec4(finalColor, 1);\n                \n            } else {\n                outColor = vec4(vec3(0, 0, 0), 1.0);\n            }\n        }\n    </script>",
      "type": "html"
    },
    {
      "code": "The Shader Programs are defined as the following, which always consists of a vertex shader and a fragment shader, which get combined into a program. For our purposes, we will only focus on the fragment shader as it is responsible for filling in the colors given a coordinate.",
      "status": "",
      "output": "The Shader Programs are defined as the following, which always consists of a vertex shader and a fragment shader, which get combined into a program. For our purposes, we will only focus on the fragment shader as it is responsible for filling in the colors given a coordinate.",
      "type": "html"
    },
    {
      "code": "//initialize the canvas and WebGL2 context\ncanvas = document.getElementById(\"myCanvas\");\ngl = canvas.getContext(\"webgl2\");\n\n//create the shaders\nvertexShaderSource = `#version 300 es\n        in vec2 a_position;\n        void main() {\n            gl_Position = vec4(a_position, 0, 1);\n        }\n`;\nfragmentShaderSource = `#version 300 es\n        //gl_FragCoord contains the pixel coordinates of the fragment\n        precision highp float;\n        uniform vec2 u_mouseLocation;\n        uniform vec2 u_canvasSize;\n        out vec4 outColor;\n\n        vec2 fragSpaceToComplex(vec2 fragCoord, float x_axis_width){\n            float canvas_x = u_canvasSize.x;\n            float canvas_y = u_canvasSize.y;\n\n            vec2 coord = fragCoord.xy - vec2(canvas_x/2.0, canvas_y/2.0);\n            coord = x_axis_width * (coord / canvas_x);\n            return coord;\n        }\n\n        vec2 func(vec2 z, vec2 c){\n            return vec2(z.x*z.x - z.y*z.y + c.x, 2.00 * z.x * z.y + c.y);\n        }\n\n        //snippet from: https://gpfault.net/posts/mandelbrot-webgl.txt.html\n        vec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n            return a + b*cos( 6.28318*(c*t+d) );\n        }\n\n        vec3 colorScheme1(float t){\n            //put in random colors\n            if (t < 0.1){\n                return vec3(0.0, 0.0, 0.5); // Dark Blue\n            } else if (t < 0.2){\n                return vec3(0.0, 0.0, 1.0); // Blue\n            } else if (t < 0.3){\n                return vec3(0.0, 0.5, 1.0); // Light Blue\n            } else if (t < 0.4){\n                return vec3(0.0, 1.0, 1.0); // Cyan\n            } else if (t < 0.5){\n                return vec3(0.0, 1.0, 0.5); // Turquoise\n            } else if (t < 0.6){\n                return vec3(0.0, 1.0, 0.0); // Green\n            } else if (t < 0.7){\n                return vec3(0.5, 1.0, 0.0); // Light Green\n            } else if (t < 0.8){\n                return vec3(1.0, 1.0, 0.0); // Yellow\n            } else if (t < 0.9){\n                return vec3(1.0, 0.5, 0.0); // Orange\n            } else {\n                return vec3(1.0, 0.0, 0.0); // Red\n            }\n        }\n\n        vec3 colorScheme2(float t){\n            if (t < 0.1){\n                return vec3(0.0, 0.0, 0.5); // Dark Blue\n            } else if (t < 0.2){\n                return vec3(0.0, 0.0, 1.0); // Blue\n            } else if (t < 0.3){\n                return vec3(0.0, 0.5, 1.0); // Light Blue\n            } else if (t < 0.4){\n                return vec3(0.0, 0.75, 1.0); // Sky Blue\n            } else if (t < 0.5){\n                return vec3(0.5, 0.75, 1.0); // Light Sky Blue\n            } else if (t < 0.6){\n                return vec3(0.75, 0.75, 1.0); // Very Light Blue\n            } else if (t < 0.7){\n                return vec3(0.9, 0.9, 1.0); // Pale Blue\n            } else if (t < 0.8){\n                return vec3(0.95, 0.95, 1.0); // Very Pale Blue\n            } else if (t < 0.9){\n                return vec3(1.0, 1.0, 1.0); // White\n            } else {\n                return vec3(0.9, 0.9, 0.9); // Light Grey\n            }\n\n        }\n\n        vec3 colorScheme3(float t){\n            if (t < 0.1){\n                return vec3(0.0, 0.5, 0.0); // Dark Green\n            } else if (t < 0.2){\n                return vec3(0.0, 0.75, 0.0); // Green\n            } else if (t < 0.3){\n                return vec3(0.5, 1.0, 0.0); // Light Green\n            } else if (t < 0.4){\n                return vec3(0.75, 1.0, 0.0); // Yellowish Green\n            } else if (t < 0.5){\n                return vec3(1.0, 1.0, 0.0); // Yellow\n            } else if (t < 0.6){\n                return vec3(1.0, 0.75, 0.0); // Orange\n            } else if (t < 0.7){\n                return vec3(1.0, 0.5, 0.0); // Dark Orange\n            } else if (t < 0.8){\n                return vec3(0.5, 0.25, 0.0); // Brown\n            } else if (t < 0.9){\n                return vec3(0.5, 0.25, 0.25); // Dark Brown\n            } else {\n                return vec3(0.25, 0.125, 0.125); // Very Dark Brown\n            }\n\n        }\n\n        \n        vec3 colorScheme4(float t){\n            if (t < 0.1){\n                return vec3(0.5, 0.0, 0.5); // Purple\n            } else if (t < 0.2){\n                return vec3(0.75, 0.0, 0.75); // Light Purple\n            } else if (t < 0.3){\n                return vec3(1.0, 0.0, 1.0); // Magenta\n            } else if (t < 0.4){\n                return vec3(1.0, 0.0, 0.75); // Pinkish Magenta\n            } else if (t < 0.5){\n                return vec3(1.0, 0.0, 0.5); // Pink\n            } else if (t < 0.6){\n                return vec3(1.0, 0.25, 0.5); // Light Pink\n            } else if (t < 0.7){\n                return vec3(1.0, 0.5, 0.5); // Salmon\n            } else if (t < 0.8){\n                return vec3(1.0, 0.75, 0.75); // Light Salmon\n            } else if (t < 0.9){\n                return vec3(1.0, 1.0, 1.0); // White\n            } else {\n                return vec3(0.9, 0.9, 0.9); // Light Grey\n            }\n\n        }\n\n\n        void main() {\n            bool escaped = false;\n            int num_iterations = 200;\n            int i = 0;\n            float x_axis_width = 3.5;\n\n            vec2 c = fragSpaceToComplex(u_mouseLocation, x_axis_width);\n            vec2 z = fragSpaceToComplex(gl_FragCoord.xy, x_axis_width);\n\n            float escape_radius = 10.0;\n\n            for (i = 0; i < num_iterations; i++) {\n                z = func(z, c);\n                \n                if (length(z) > escape_radius) {\n                    escaped = true;\n                    break;\n                }\n            }\n\n            if (escaped) {\n                float param = float(i) / float(num_iterations);\n                vec3 finalColor = colorScheme4(param);\n                outColor = vec4(finalColor, 1);\n                \n            } else {\n                outColor = vec4(vec3(0, 0, 0), 1.0);\n            }\n        }\n`\nshow(\"\");",
      "status": "[9]<br><span style=\"font-size:8px\">8ms<span></span></span>",
      "output": " <br>",
      "type": "code"
    },
    {
      "code": "And here is the rest of the program that processes the shader code into a webGL output, while also setting the mouse position as a uniform variable to be fed back into the shader.",
      "status": "",
      "output": "And here is the rest of the program that processes the shader code into a webGL output, while also setting the mouse position as a uniform variable to be fed back into the shader.",
      "type": "html"
    },
    {
      "code": "canvas_width = 640;\ncanvas_height = 480;\n\n//helper functions\nwindow.addEventListener('mousemove', event => {\n    canvas_top = canvas.getBoundingClientRect().top;\n  \tcanvas_left = canvas.getBoundingClientRect().left;\n    mouseLocation = { x: event.clientX - canvas_left, y: event.clientY - canvas_top}; //adjust the center to be the canvas center\n    drawScene();  //redraw the scene when the mouse moves\n});\n\nfunction browserToFragCoords(browserLocation){\n    return {x: browserLocation.x, y: gl.canvas.height - browserLocation.y};\n}\n\nfunction createShader(gl, type, source) {\n    var shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n\n    var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    if (success){\n        return shader;\n    }\n\n    console.log(gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n}\n\nfunction createProgram(gl, vertexShader, fragmentShader){\n    var program = gl.createProgram();\n\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n\n    var success = gl.getProgramParameter(program, gl.LINK_STATUS);\n\n    if(success){\n        return program;\n    }\n\n    console.log(gl.getProgramInfoLog(program));\n    gl.deleteProgram(program);\n}\n\nfunction setCanvasDimensions(){\n    //canvas.width = window.innerWidth;\n    //canvas.height = window.innerHeight;\n  \n  \tcanvas.width = canvas_width;\n  \tcanvas.height = canvas_height;\n}\n\nfunction placeDataInBuffer(){\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n    var positions = [\n        -1, -1,\n        -1,  1,\n         1, -1,\n         1, -1,\n        -1,  1,\n         1,  1\n    ];\n\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\n}\n\nfunction drawScene(){\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    gl.useProgram(program);\n\n    gl.enableVertexAttribArray(positionAttributeLocation);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n    var size = 2;\n    var type = gl.FLOAT;\n    var normalize = false;\n    var stride = 0;\n    var offset = 0;\n\n    gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\n\n    //set the canvas size uniform\n    gl.uniform2f(canvasSizeUniformLocation, gl.canvas.width, gl.canvas.height);\n    \n    //set the mouse location uniform\n    let mouseFragCoords = browserToFragCoords(mouseLocation);\n    gl.uniform2f(mouseLocationUniformLocation, mouseFragCoords.x, mouseFragCoords.y);\n\n    var primitiveType = gl.TRIANGLES;\n    var count = 6;\n\n    gl.drawArrays(primitiveType, offset, count);\n\n}\n\nfunction main(){\n    setCanvasDimensions();\n    placeDataInBuffer();\n    drawScene();\n}\n\nvertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\nfragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n\n//create the program\nprogram = createProgram(gl, vertexShader, fragmentShader);\n\n//uniform locations\npositionAttributeLocation = gl.getAttribLocation(program, 'a_position');\nmouseLocationUniformLocation = gl.getUniformLocation(program, \"u_mouseLocation\");\ncanvasSizeUniformLocation = gl.getUniformLocation(program, \"u_canvasSize\");\n\n//create the buffer\npositionBuffer = gl.createBuffer();\n\n//variables related to the mouse location\nmouseLocation = {x: 0.0, y: 0.0};\n\n\nmain();",
      "status": "[10]<br><span style=\"font-size:8px\">9ms<span></span></span>",
      "output": "",
      "type": "code"
    },
    {
      "code": "<h2>Part II: Perlin Noise and Audio Frequency Binning</h2>",
      "status": "",
      "output": "<h2>Part II: Perlin Noise and Audio Frequency Binning</h2>",
      "type": "html"
    },
    {
      "code": "Another graphic we can make that fits the form f(x, y) -> color is Perlin Noise. Perlin Noise is basically a much more \"organic\" looking form of random noise (which, is, well, random). \nI will skip over how Perlin noise works and go straight to implementation; unlike the Julia Set shader program, I will adapt an existing implementation into my existing boilerplate WebGL code instead of making it from scratch. The Perlin Noise implementation is borrowed from <a href=\"https://medium.com/neosavvy-labs/webgl-with-perlin-noise-part-1-a87b56bbc9fb#:~:text=Perlin%20Noise%20can%20be%20used,extended%20into%20the%204th%20dimension.\">this tutorial on perlin noise</a>.",
      "status": "",
      "output": "Another graphic we can make that fits the form f(x, y) -&gt; color is Perlin Noise. Perlin Noise is basically a much more \"organic\" looking form of random noise (which, is, well, random). \nI will skip over how Perlin noise works and go straight to implementation; unlike the Julia Set shader program, I will adapt an existing implementation into my existing boilerplate WebGL code instead of making it from scratch. The Perlin Noise implementation is borrowed from <a href=\"https://medium.com/neosavvy-labs/webgl-with-perlin-noise-part-1-a87b56bbc9fb#:~:text=Perlin%20Noise%20can%20be%20used,extended%20into%20the%204th%20dimension.\">this tutorial on perlin noise</a>.",
      "type": "html"
    },
    {
      "code": "<style>\n  #myCanvasPerlin {\n\twidth:640px;\n\theight:480px;\n  }\n </style>\n<canvas id=\"myCanvasPerlin\"></canvas>",
      "status": "",
      "output": "<style>\n  #myCanvasPerlin {\n\twidth:640px;\n\theight:480px;\n  }\n </style>\n<canvas id=\"myCanvasPerlin\" width=\"1512\" height=\"759\"></canvas>",
      "type": "html"
    },
    {
      "code": "The (fragment) shader looks like the following. It consists of the noise() function implementing Perlin noise, and a turbulence function which is a wrapper around the noise() function to adjust its curl its curl parameter. Finally the cloud function sets the curl as a function of time (time is obtained from the javascript code through a uniform variable) so that the output looks like a \nfluid:",
      "status": "",
      "output": "The (fragment) shader looks like the following. It consists of the noise() function implementing Perlin noise, and a turbulence function which is a wrapper around the noise() function to adjust its curl its curl parameter. Finally the cloud function sets the curl as a function of time (time is obtained from the javascript code through a uniform variable) so that the output looks like a \nfluid:",
      "type": "html"
    },
    {
      "code": "fragmentShaderSource = `\nprecision highp float;\n\nuniform vec2 u_canvasSize;\nuniform float u_time;\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n\nfloat noise(vec3 P) {\n    vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));\n    vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);\n    vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);\n    vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;\n    vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0); gx1 = fract(gx1);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n    vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),\n        g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),\n        g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),\n        g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));\n    g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;\n    g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;\n    vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),\n        dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),\n        vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),\n            dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);\n    return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);\n}\nfloat noise(vec2 P) { return noise(vec3(P, 0.0)); }\n\nvec2 normalizeByWidth(vec2 P) {\n    return P / u_canvasSize.x;\n}\n\nfloat turbulence(vec3 P) {\n    float f = 0., s = 1.;\n    for (int i = 0 ; i < 9 ; i++) {\n        f += abs(noise(s * P)) / s;\n        s *= 2.;\n        P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);\n    }\n    return f;\n}\n\nvec3 clouds(float x, float y) {\n    float L = turbulence(vec3(x, y, u_time * .1));\n    return vec3(noise(vec3(0.5, 0.5, L) * 0.7));\n}\n\nvoid main() {\n    vec3 color;\n    vec2 vPosition = normalizeByWidth(gl_FragCoord.xy);\n    float x = vPosition.x;\n    float y = vPosition.y;\n\n    vec3 cloudEffect = clouds(vPosition.x, vPosition.y);\n    color = cloudEffect + vec3(.5, .8, 0.95);\n    gl_FragColor = vec4(color, 1.);\n}\n`\n\nshow(\"\")",
      "status": "[2]<br><span style=\"font-size:8px\">0ms<span></span></span>",
      "output": " <br>",
      "type": "code"
    },
    {
      "code": "var canvas = document.getElementById('myCanvasPerlin');\nvar gl = canvas.getContext('webgl');\n\nvar startTimeInSeconds = new Date().getTime()\nstartTimeInSeconds = startTimeInSeconds/1000;\n\nconst vertexShaderSource = `\n    attribute vec2 a_position;\n    void main() {\n        gl_Position = vec4(a_position, 0.0, 1.0);\n    }\n`;\n\nconst vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\nconst fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n\nvar program = createProgram(gl, vertexShader, fragmentShader);\n\n//uniform locations\nvar positionAttributeLocation = gl.getAttribLocation(program, 'a_position');\nvar canvasSizeUniformLocation = gl.getUniformLocation(program, \"u_canvasSize\");\nvar timeUniformLocation = gl.getUniformLocation(program, \"u_time\");\n\n//create the buffer\nvar positionBuffer = gl.createBuffer();\n\nfunction setCanvasDimensions(){\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n}\n\nfunction createShader(gl, type, source) {\n    var shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n\n    var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    if (success){\n        return shader;\n    }\n\n    console.log(gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n}\n\nfunction createProgram(gl, vertexShader, fragmentShader){\n    var program = gl.createProgram();\n\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n\n    var success = gl.getProgramParameter(program, gl.LINK_STATUS);\n\n    if(success){\n        return program;\n    }\n\n    console.log(gl.getProgramInfoLog(program));\n    gl.deleteProgram(program);\n}\n\n\n\nfunction placeDataInBuffer(){\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n    var positions = [\n        -1, -1,\n        -1,  1,\n         1, -1,\n         1, -1,\n        -1,  1,\n         1,  1\n    ];\n\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\n}\n\n\nfunction drawScene(){\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    gl.useProgram(program);\n\n    gl.enableVertexAttribArray(positionAttributeLocation);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n    var size = 2;\n    var type = gl.FLOAT;\n    var normalize = false;\n    var stride = 0;\n    var offset = 0;\n\n    gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\n\n    //set the canvas size uniform\n    gl.uniform2f(canvasSizeUniformLocation, gl.canvas.width, gl.canvas.height);\n    \n    //set the time uniform\n    let currentTimeInSeconds = new Date().getTime()\n    currentTimeInSeconds = currentTimeInSeconds/1000;\n    gl.uniform1f(timeUniformLocation, currentTimeInSeconds - startTimeInSeconds);\n\n    var primitiveType = gl.TRIANGLES;\n    var count = 6;\n\n    gl.drawArrays(primitiveType, offset, count);\n\n}\n\nfunction main(){\n    setCanvasDimensions();\n    placeDataInBuffer();\n    drawScene();\n}\n\nsetInterval(main, 1000/60);\n\n\n\n",
      "status": "[3]<br><span style=\"font-size:8px\">9ms<span></span></span>",
      "output": "170 <br>",
      "type": "code"
    },
    {
      "code": "Now here's the idea: we will take an audio clip, extract the weights of the different frequencies being played in the audio as a function of time, group those weights together, and use these weight values are parameters into the perlin noise display to build a music visualizer.\n<br>\nFirst, we obtain the audio clip: I am using the Deezer API to extract a 30 second preview of \"Paint the Town Red\". This method can of course be extended to multiple songs you can switch between.\n",
      "status": "",
      "output": "Now here's the idea: we will take an audio clip, extract the weights of the different frequencies being played in the audio as a function of time, group those weights together, and use these weight values are parameters into the perlin noise display to build a music visualizer.\n<br>\nFirst, we obtain the audio clip: I am using the Deezer API to extract a 30 second preview of \"Paint the Town Red\". This method can of course be extended to multiple songs you can switch between.\n",
      "type": "html"
    },
    {
      "code": "We can now process and plot the frequency weights in a nice visualization:",
      "status": "",
      "output": "We can now process and plot the frequency weights in a nice visualization:",
      "type": "html"
    },
    {
      "code": "<style>\n  #myCanvasAudio {\n\twidth:640px;\n\theight:480px;\n  }   \n</style>\n<audio id=\"audio\" crossorigin=\"anonymous\" controls></audio>\n <canvas id=\"myCanvasAudio\"></canvas>",
      "status": "",
      "output": "<style>\n  #myCanvasAudio {\n\twidth:640px;\n\theight:480px;\n  }   \n</style>\n<audio id=\"audio\" crossorigin=\"anonymous\" controls=\"\" src=\"https://cdns-preview-f.dzcdn.net/stream/c-f27771b87d90d82f52ad83b932130078-1.mp3\"></audio>\n <canvas id=\"myCanvasAudio\" width=\"1512\" height=\"759\"></canvas>",
      "type": "html"
    },
    {
      "code": "First, the XMLHttpRequest to obtain the track:",
      "status": "",
      "output": "First, the XMLHttpRequest to obtain the track:",
      "type": "html"
    },
    {
      "code": "data = null;\n\nxhr = new XMLHttpRequest();\nxhr.withCredentials = true;\n\nxhr.addEventListener('readystatechange', function () {\n    if (this.readyState === this.DONE) {\n        response = JSON.parse(this.responseText);\n        audioUrl = response.preview;\n\n        audioTag = document.getElementById('audio');\n        audioTag.src = audioUrl;\n    }\n});\n\nxhr.open('GET', 'https://deezerdevs-deezer.p.rapidapi.com/track/2459517655');\nxhr.setRequestHeader('X-RapidAPI-Key', '72a07891a0mshf0b1eaca04b5b16p152df9jsn8502a0d17c56');\nxhr.setRequestHeader('X-RapidAPI-Host', 'deezerdevs-deezer.p.rapidapi.com');\n\nxhr.send(data);",
      "status": "[4]<br><span style=\"font-size:8px\">0ms<span></span></span>",
      "output": "",
      "type": "code"
    },
    {
      "code": "canvas = document.getElementById('myCanvasAudio');\ncanvas.width = window.innerWidth;\ncanvas.height = window.innerHeight;\nctx = canvas.getContext('2d');\n\n// Create a new AudioContext\nconst audioContext = new (window.AudioContext || window.webkitAudioContext)();\n\n// Create an audio source from the audio tag\nconst audioElement = document.getElementById('audio');\nconst audioSource = audioContext.createMediaElementSource(audioElement);\n\n// Create a new analyser node\nconst analyser = audioContext.createAnalyser();\n\n// Connect the audio source to the analyser\naudioSource.connect(analyser);\n\n// Also connect the audio source to the audio context's destination\naudioSource.connect(audioContext.destination);\n\naudioElement.addEventListener('play', function() {\n    audioContext.resume().then(() => {\n        // console.log('Playback resumed successfully');\n    });\n});\n\n// Use the analyser node to get the frequency data\nconst frequencyData = new Uint8Array(analyser.frequencyBinCount);\n\nlet numBars = 30;\nlet dataPointsPerBar = Math.floor(frequencyData.length / numBars);\n\nfunction updateFrequencyData() {\n    // Get the frequency data and update the visualization\n    analyser.getByteFrequencyData(frequencyData);\n    console.log(frequencyData);\n\n    // Use frequencyData here to update your visualization\n    // Clear the canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Draw the frequency data as a bar chart\n    for (let i = 0; i < numBars; i++) {\n        // Calculate the average frequency for this bar\n        let sum = 0;\n        for (let j = 0; j < dataPointsPerBar; j++) {\n            sum += frequencyData[(i * dataPointsPerBar) + j];\n        }\n        const value = sum / dataPointsPerBar;\n\n        // Draw the bar\n        const percent = value / 255;\n        const height = canvas.height * percent;\n        const offset = canvas.height - height - 1;\n        const barWidth = canvas.width / numBars;\n        ctx.fillStyle = 'black';\n        ctx.fillRect(i * barWidth, offset, barWidth, height);\n    }\n\n    // Call this function again when the next frame is ready\n    requestAnimationFrame(updateFrequencyData);\n}\n\n// Start updating the frequency data\nupdateFrequencyData();",
      "status": "[5]<br><span style=\"font-size:8px\">6ms<span></span></span>",
      "output": "",
      "type": "code"
    },
    {
      "code": "<h2>Part III: Putting it all Together</h2>",
      "status": "",
      "output": "<h2>Part III: Putting it all Together</h2>",
      "type": "html"
    },
    {
      "code": "We now extract parameters from the frequency weights, by first binning the frequencies into three groups (i.e. the weights of low, medium and high frequencies)\neach with a value between 0 and 255. We now use uniform variables to pass these parameters to the shader program. The low and high frequency parameters are assigned to change the colors\nwhile the middle frequency parameter is used to alter the \"time elapsed\" of the perlin noise, since there is a u_time uniform behaving as time in this fluid-like perlin noise setup, so altering that would amount to essentially forwarding and reversing time. Of course, there is enormous potential for tweaking within this visualizer. One could even interact with the visualizer if we add the mouse position as another parameter.\n<br>\n  <br>\n  Here's what everything put together looks like:",
      "status": "",
      "output": "We now extract parameters from the frequency weights, by first binning the frequencies into three groups (i.e. the weights of low, medium and high frequencies)\neach with a value between 0 and 255. We now use uniform variables to pass these parameters to the shader program. The low and high frequency parameters are assigned to change the colors\nwhile the middle frequency parameter is used to alter the \"time elapsed\" of the perlin noise, since there is a u_time uniform behaving as time in this fluid-like perlin noise setup, so altering that would amount to essentially forwarding and reversing time. Of course, there is enormous potential for tweaking within this visualizer. One could even interact with the visualizer if we add the mouse position as another parameter.\n<br>\n  <br>\n  Here's what everything put together looks like:",
      "type": "html"
    },
    {
      "code": "<style>\n  #myCanvasFinal {\n\twidth:640px;\n\theight:480px;\n  }   \n</style>\n    <div id=\"container\">\n        <canvas id=\"myCanvasFinal\"></canvas>\n            <audio id=\"audioFinal\" crossorigin=\"anonymous\" controls>\n            </audio>\n    </div>",
      "status": "",
      "output": "<style>\n  #myCanvasFinal {\n\twidth:640px;\n\theight:480px;\n  }   \n</style>\n    <div id=\"container\">\n        <canvas id=\"myCanvasFinal\" width=\"1512\" height=\"759\"></canvas>\n            <audio id=\"audioFinal\" crossorigin=\"anonymous\" controls=\"\" src=\"https://cdns-preview-f.dzcdn.net/stream/c-f27771b87d90d82f52ad83b932130078-1.mp3\">\n            </audio>\n    </div>",
      "type": "html"
    },
    {
      "code": "var canvas = document.getElementById('myCanvasFinal');\nvar gl = canvas.getContext('webgl');\n\nvar startTimeInSeconds = new Date().getTime()\nstartTimeInSeconds = startTimeInSeconds/1000;\n\nconst vertexShaderSource = `\n    attribute vec2 a_position;\n    void main() {\n        gl_Position = vec4(a_position, 0.0, 1.0);\n    }\n`;\n\nconst fragmentShaderSource = `\nprecision highp float;\n\nuniform vec2 u_canvasSize;\nuniform float u_time;\nuniform float u_freqParam1;\nuniform float u_freqParam2;\nuniform float u_freqParam3;\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n\nfloat noise(vec3 P) {\n    vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));\n    vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);\n    vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);\n    vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;\n    vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0); gx1 = fract(gx1);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n    vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),\n        g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),\n        g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),\n        g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));\n    g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;\n    g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;\n    vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),\n        dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),\n        vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),\n            dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);\n    return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);\n}\nfloat noise(vec2 P) { return noise(vec3(P, 0.0)); }\n\nvec2 normalizeByWidth(vec2 P) {\n    return P / u_canvasSize.x;\n}\n\nfloat turbulence(vec3 P) {\n    float f = 0., s = 1.;\n    for (int i = 0 ; i < 9 ; i++) {\n        f += abs(noise(s * P)) / s;\n        s *= 2.;\n        P = vec3(.866 * P.x + .5 * P.z, P.y + 100., -.5 * P.x + .866 * P.z);\n    }\n    return f;\n}\n\nvec3 clouds(float x, float y) {\n    float L = turbulence(vec3(x, y, u_time * .1 + 0.5*u_freqParam2/255. ));\n    return vec3(noise(vec3(u_freqParam2/255., 0.5, L) * 0.7));\n}\n\nvoid main() {\n    vec3 color;\n    vec2 vPosition = normalizeByWidth(gl_FragCoord.xy);\n    float x = vPosition.x;\n    float y = vPosition.y;\n\n    vec3 cloudEffect = clouds(vPosition.x, vPosition.y);\n    color = cloudEffect + vec3(0.6, u_freqParam1/255., u_freqParam3/255.);\n    gl_FragColor = vec4(color, 1.);\n}\n`\n\nconst vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\nconst fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n\nvar program = createProgram(gl, vertexShader, fragmentShader);\n\n//uniform locations\nvar positionAttributeLocation = gl.getAttribLocation(program, 'a_position');\nvar canvasSizeUniformLocation = gl.getUniformLocation(program, \"u_canvasSize\");\nvar timeUniformLocation = gl.getUniformLocation(program, \"u_time\");\n\n//create the buffer\nvar positionBuffer = gl.createBuffer();\n\nfunction setCanvasDimensions(){\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n}\n\nfunction createShader(gl, type, source) {\n    var shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n\n    var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    if (success){\n        return shader;\n    }\n\n    console.log(gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n}\n\nfunction createProgram(gl, vertexShader, fragmentShader){\n    var program = gl.createProgram();\n\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n\n    var success = gl.getProgramParameter(program, gl.LINK_STATUS);\n\n    if(success){\n        return program;\n    }\n\n    console.log(gl.getProgramInfoLog(program));\n    gl.deleteProgram(program);\n}\n\n\n\nfunction placeDataInBuffer(){\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n    var positions = [\n        -1, -1,\n        -1,  1,\n         1, -1,\n         1, -1,\n        -1,  1,\n         1,  1\n    ];\n\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\n}\n\n\nfunction drawScene(){\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    gl.useProgram(program);\n\n    gl.enableVertexAttribArray(positionAttributeLocation);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n    var size = 2;\n    var type = gl.FLOAT;\n    var normalize = false;\n    var stride = 0;\n    var offset = 0;\n\n    gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\n\n    //set the canvas size uniform\n    gl.uniform2f(canvasSizeUniformLocation, gl.canvas.width, gl.canvas.height);\n    \n    //set the time uniform\n    let currentTimeInSeconds = new Date().getTime()\n    currentTimeInSeconds = currentTimeInSeconds/1000;\n    gl.uniform1f(timeUniformLocation, currentTimeInSeconds - startTimeInSeconds);\n\n    //set the frequency parameter uniforms\n    analyser.getByteFrequencyData(frequencyData);\n    let groupedFrequencyData = makeGroupedFrequencyData(3);\n    let freqParam1 = frequencyData[0];\n    let freqParam2 = frequencyData[1];\n    let freqParam3 = frequencyData[2];\n    gl.uniform1f(gl.getUniformLocation(program, \"u_freqParam1\"), freqParam1);\n    gl.uniform1f(gl.getUniformLocation(program, \"u_freqParam2\"), freqParam2);\n    gl.uniform1f(gl.getUniformLocation(program, \"u_freqParam3\"), freqParam3);\n\n\n    var primitiveType = gl.TRIANGLES;\n    var count = 6;\n\n    gl.drawArrays(primitiveType, offset, count);\n\n}\n\nfunction main(){\n    setCanvasDimensions();\n    placeDataInBuffer();\n    drawScene();\n}\n\nconst data = null;\n\nconst xhr = new XMLHttpRequest();\nxhr.withCredentials = true;\n\nxhr.addEventListener('readystatechange', function () {\n    if (this.readyState === this.DONE) {\n        const response = JSON.parse(this.responseText);\n        const audioUrl = response.preview;\n\n        const audioTag = document.getElementById('audioFinal');\n        audioTag.src = audioUrl;\n\n        // Create a new Audio object and start playing the audio\n        // const audio = new Audio(audioUrl);\n        // audio.play();\n    }\n});\n\nxhr.open('GET', 'https://deezerdevs-deezer.p.rapidapi.com/track/2459517655');\nxhr.setRequestHeader('X-RapidAPI-Key', '72a07891a0mshf0b1eaca04b5b16p152df9jsn8502a0d17c56');\nxhr.setRequestHeader('X-RapidAPI-Host', 'deezerdevs-deezer.p.rapidapi.com');\n\nxhr.send(data);\n\n// Create a new AudioContext\nconst audioContext = new (window.AudioContext || window.webkitAudioContext)();\n\n// Create an audio source from the audio tag\nconst audioElement = document.getElementById('audioFinal');\nconst audioSource = audioContext.createMediaElementSource(audioElement);\n\n// Create a new analyser node\nconst analyser = audioContext.createAnalyser();\n\n// Connect the audio source to the analyser\naudioSource.connect(analyser);\n\n// Also connect the audio source to the audio context's destination\naudioSource.connect(audioContext.destination);\n\naudioElement.addEventListener('play', function() {\n    audioContext.resume().then(() => {\n        // console.log('Playback resumed successfully');\n    });\n});\n\n// Use the analyser node to get the frequency data\nvar frequencyData = new Uint8Array(analyser.frequencyBinCount);\n\nfunction makeGroupedFrequencyData(numBars){\n    let dataPointsPerBar = Math.floor(frequencyData.length / numBars);\n    let groupedFrequencyData = [];\n    for (let i = 0; i < numBars; i++){\n        let sum = 0;\n        for (let j = 0; j < dataPointsPerBar; j++){\n            sum += frequencyData[i*dataPointsPerBar + j];\n        }\n        groupedFrequencyData.push(sum);\n    }\n    return groupedFrequencyData;\n}\n\n\nsetInterval(main, 1000/60);\n\n\n\n",
      "status": "[6]<br><span style=\"font-size:8px\">7ms<span></span></span>",
      "output": "181 <br>",
      "type": "code"
    },
    {
      "code": "",
      "status": "[7]<br><span style=\"font-size:8px\">0ms<span></span></span>",
      "output": "",
      "type": "code"
    },
    {
      "code": "",
      "status": "[8]<br><span style=\"font-size:8px\">0ms<span></span></span>",
      "output": "",
      "type": "code"
    }
  ],
  "source": "https://github.com/gopi-suvanam/jsnb",
  "run_on_load": false
}
